// Autogenerated - do not edit
#include "RTMB.h"
// [[Rcpp::export]]
ADrep distr_dexp ( ADrep x, ADrep rate, bool give_log )
{
int n1=x.size();
int n2=rate.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(rate);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dexp(X1[i % n1], X2[i % n2], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dweibull ( ADrep x, ADrep shape, ADrep scale, bool give_log )
{
int n1=x.size();
int n2=shape.size();
int n3=scale.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dweibull(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dbinom ( ADrep x, ADrep size, ADrep prob, bool give_log )
{
int n1=x.size();
int n2=size.size();
int n3=prob.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(size); const ad* X3 = adptr(prob);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dbinom(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dbinom_robust ( ADrep x, ADrep size, ADrep logit_p, bool give_log )
{
int n1=x.size();
int n2=size.size();
int n3=logit_p.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(size); const ad* X3 = adptr(logit_p);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dbinom_robust(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dbeta ( ADrep x, ADrep shape1, ADrep shape2, bool give_log )
{
int n1=x.size();
int n2=shape1.size();
int n3=shape2.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(shape1); const ad* X3 = adptr(shape2);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dbeta(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_df ( ADrep x, ADrep df1, ADrep df2, bool give_log )
{
int n1=x.size();
int n2=df1.size();
int n3=df2.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(df1); const ad* X3 = adptr(df2);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = df(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dlogis ( ADrep x, ADrep location, ADrep scale, bool give_log )
{
int n1=x.size();
int n2=location.size();
int n3=scale.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(location); const ad* X3 = adptr(scale);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dlogis(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dsn ( ADrep x, ADrep alpha, bool give_log )
{
int n1=x.size();
int n2=alpha.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(alpha);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dsn(X1[i % n1], X2[i % n2], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dt ( ADrep x, ADrep df, bool give_log )
{
int n1=x.size();
int n2=df.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(df);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dt(X1[i % n1], X2[i % n2], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dSHASHo ( ADrep x, ADrep mu, ADrep sigma, ADrep nu, ADrep tau, bool give_log )
{
int n1=x.size();
int n2=mu.size();
int n3=sigma.size();
int n4=nu.size();
int n5=tau.size();
int nmax = std::max({n1, n2, n3, n4, n5});
int nmin = std::min({n1, n2, n3, n4, n5});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(mu); const ad* X3 = adptr(sigma); const ad* X4 = adptr(nu); const ad* X5 = adptr(tau);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dSHASHo(X1[i % n1], X2[i % n2], X3[i % n3], X4[i % n4], X5[i % n5], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dtweedie ( ADrep x, ADrep mu, ADrep phi, ADrep p, bool give_log )
{
int n1=x.size();
int n2=mu.size();
int n3=phi.size();
int n4=p.size();
int nmax = std::max({n1, n2, n3, n4});
int nmin = std::min({n1, n2, n3, n4});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(mu); const ad* X3 = adptr(phi); const ad* X4 = adptr(p);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dtweedie(X1[i % n1], X2[i % n2], X3[i % n3], X4[i % n4], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dnbinom ( ADrep x, ADrep size, ADrep prob, bool give_log )
{
int n1=x.size();
int n2=size.size();
int n3=prob.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(size); const ad* X3 = adptr(prob);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dnbinom(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dnbinom_robust ( ADrep x, ADrep log_mu, ADrep log_var_minus_mu, bool give_log )
{
int n1=x.size();
int n2=log_mu.size();
int n3=log_var_minus_mu.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(log_mu); const ad* X3 = adptr(log_var_minus_mu);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dnbinom_robust(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dnbinom2 ( ADrep x, ADrep mu, ADrep var, bool give_log )
{
int n1=x.size();
int n2=mu.size();
int n3=var.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(mu); const ad* X3 = adptr(var);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dnbinom2(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dpois ( ADrep x, ADrep lambda, bool give_log )
{
int n1=x.size();
int n2=lambda.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(lambda);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dpois(X1[i % n1], X2[i % n2], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dgamma ( ADrep x, ADrep shape, ADrep scale, bool give_log )
{
int n1=x.size();
int n2=shape.size();
int n3=scale.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dgamma(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_dlgamma ( ADrep x, ADrep shape, ADrep scale, bool give_log )
{
int n1=x.size();
int n2=shape.size();
int n3=scale.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(x); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = dlgamma(X1[i % n1], X2[i % n2], X3[i % n3], give_log);
return ans;
}
// [[Rcpp::export]]
ADrep distr_pnorm ( ADrep q, ADrep mean , ADrep sd  )
{
int n1=q.size();
int n2=mean .size();
int n3=sd .size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(q); const ad* X2 = adptr(mean ); const ad* X3 = adptr(sd );
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = pnorm(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_pgamma ( ADrep q, ADrep shape, ADrep scale  )
{
int n1=q.size();
int n2=shape.size();
int n3=scale .size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(q); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale );
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = pgamma(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_ppois ( ADrep q, ADrep lambda )
{
int n1=q.size();
int n2=lambda.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(q); const ad* X2 = adptr(lambda);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = ppois(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_pexp ( ADrep q, ADrep rate )
{
int n1=q.size();
int n2=rate.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(q); const ad* X2 = adptr(rate);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = pexp(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_pweibull ( ADrep q, ADrep shape, ADrep scale )
{
int n1=q.size();
int n2=shape.size();
int n3=scale.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(q); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = pweibull(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_pbeta ( ADrep q, ADrep shape1, ADrep shape2 )
{
int n1=q.size();
int n2=shape1.size();
int n3=shape2.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(q); const ad* X2 = adptr(shape1); const ad* X3 = adptr(shape2);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = pbeta(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_qnorm ( ADrep p, ADrep mean , ADrep sd  )
{
int n1=p.size();
int n2=mean .size();
int n3=sd .size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(p); const ad* X2 = adptr(mean ); const ad* X3 = adptr(sd );
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = qnorm(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_qgamma ( ADrep p, ADrep shape, ADrep scale  )
{
int n1=p.size();
int n2=shape.size();
int n3=scale .size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(p); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale );
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = qgamma(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_qexp ( ADrep p, ADrep rate )
{
int n1=p.size();
int n2=rate.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(p); const ad* X2 = adptr(rate);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = qexp(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_qweibull ( ADrep p, ADrep shape, ADrep scale )
{
int n1=p.size();
int n2=shape.size();
int n3=scale.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(p); const ad* X2 = adptr(shape); const ad* X3 = adptr(scale);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = qweibull(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_qbeta ( ADrep p, ADrep shape1, ADrep shape2 )
{
int n1=p.size();
int n2=shape1.size();
int n3=shape2.size();
int nmax = std::max({n1, n2, n3});
int nmin = std::min({n1, n2, n3});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(p); const ad* X2 = adptr(shape1); const ad* X3 = adptr(shape2);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = qbeta(X1[i % n1], X2[i % n2], X3[i % n3]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_compois_calc_logZ ( ADrep loglambda, ADrep nu )
{
int n1=loglambda.size();
int n2=nu.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(loglambda); const ad* X2 = adptr(nu);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = compois_calc_logZ(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_compois_calc_loglambda ( ADrep logmean, ADrep nu )
{
int n1=logmean.size();
int n2=nu.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(logmean); const ad* X2 = adptr(nu);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = compois_calc_loglambda(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_lbeta ( ADrep a, ADrep b )
{
int n1=a.size();
int n2=b.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(a); const ad* X2 = adptr(b);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = lbeta(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_logspace_add ( ADrep logx, ADrep logy )
{
int n1=logx.size();
int n2=logy.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(logx); const ad* X2 = adptr(logy);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = logspace_add(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
ADrep distr_logspace_sub ( ADrep logx, ADrep logy )
{
int n1=logx.size();
int n2=logy.size();
int nmax = std::max({n1, n2});
int nmin = std::min({n1, n2});
int n = (nmin == 0 ? 0 : nmax);
ADrep ans(n);
const ad* X1 = adptr(logx); const ad* X2 = adptr(logy);
ad* Y = adptr(ans);
for (int i=0; i<n; i++) Y[i] = logspace_sub(X1[i % n1], X2[i % n2]);
return ans;
}
// [[Rcpp::export]]
double distr_rcompois(double loglambda, double nu) { return atomic::compois_utils::simulate(loglambda, nu); }
