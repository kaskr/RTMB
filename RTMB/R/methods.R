################################################################################
## This file contains:
## - Methods for sparse matrices
## - Methods for dense matrices
## - Hand written distributions (Autogenerated are in 'distributions.R')
################################################################################

setMethod("show", "advector", function(object) print.advector(object) )

setAs("sparseMatrix", "adsparse",
      function(from) {
          x <- from
          x <- as(x, "generalMatrix")
          x <- as(x, "CsparseMatrix")
          new("adsparse", x=advector(x@x), i=x@i, p=x@p, Dim=x@Dim)
      })

setAs("advector", "sparseMatrix",
      function(from) Dense2Sparse(as.matrix(from)) )

################################################################################
## Utilities to reuse methods from the Matrix package
################################################################################
IndexMap <- function(x) new("dgCMatrix",
                            i=x@i, p=x@p, Dim=x@Dim, x=as.numeric(seq_along(x@x)))
ApplyMatrixMethod <- function(method, x, ...) {
    if (is.character(method))
        method <- match.fun(method)
    ans <- method(IndexMap(x), ...)
    if (!is.null(dim(ans))) {
        ans <- as(as(ans, "generalMatrix"), "sparseMatrix")
        new("adsparse", i=ans@i, p=ans@p, Dim=ans@Dim, x=x@x[ans@x])
    }
    else
        c(advector(0), x@x)[ans + 1L]
}
ApplyMatrixReplaceMethod <- function(method, x, ..., value) {
    method <- match.fun(method)
    xmap <- IndexMap(x)
    vmap <- seq_along(value) + length(x@x)
    ans <- method(xmap, ..., value=vmap)
    if (is.null(dim(ans))) stop("unexpected")
    ans <- as(as(ans, "generalMatrix"), "sparseMatrix")
    new("adsparse", i=ans@i, p=ans@p, Dim=ans@Dim,
        x=c(advector(0), x@x, value)[ans@x + 1L])
}

##' @describeIn ADmatrix AD sparse matrix transpose. Re-directs to \link[Matrix]{t,CsparseMatrix-method}.
##' @return Object of class \code{advector} with a dimension attribute for dense matrix operations; Object of class \code{adsparse} for sparse matrix operations.
t.adsparse <- function(x) ApplyMatrixMethod(Matrix::t, x)
##' @describeIn ADmatrix AD sparse matrix subsetting. Re-directs to \link[Matrix]{[-methods}.
"[.adsparse" <- function(x, ...) ApplyMatrixMethod("[", x, ...)
##' @describeIn ADmatrix AD sparse matrix subset assignment. Re-directs to \link[Matrix]{[<--methods}.
##' @param value Replacement value
"[<-.adsparse" <- function(x, ..., value) {
    x <- ApplyMatrixReplaceMethod("[<-", x, ..., value=value)
    x
}
##' @describeIn ADmatrix Convert AD sparse to dense matrix.
as.matrix.adsparse <- function(x, ...) {
    x + matrix(0, nrow(x), ncol(x))
}
##' @describeIn ADmatrix AD sparse matrix diagonal extract. Re-directs to \link[Matrix]{diag,CsparseMatrix-method}.
setMethod("diag", c("adsparse", "missing", "missing"), function(x) ApplyMatrixMethod("diag", x) )

##' @describeIn ADmatrix AD sparse matrix band extract. Re-directs to \link[Matrix]{band,CsparseMatrix-method}.
##' @param k See Matrix package
##' @param k1 See Matrix package
##' @param k2 See Matrix package
setMethod("band", c("adsparse"),
          function(x, k1, k2) ApplyMatrixMethod("band", x, k1=k1, k2=k2) )
##' @describeIn ADmatrix AD sparse matrix lower triangle extract. Re-directs to \link[Matrix]{tril,CsparseMatrix-method}.
setMethod("tril", c("adsparse"),
          function(x, k) ApplyMatrixMethod("tril", x, k=k) )
##' @describeIn ADmatrix AD sparse matrix upper triangle extract. Re-directs to \link[Matrix]{triu,CsparseMatrix-method}.
setMethod("triu", c("adsparse"),
          function(x, k) ApplyMatrixMethod("triu", x, k=k) )

##setClassUnion("advector_castable", c("advector", "numeric"))

##' @describeIn ADmatrix AD matrix exponential
setMethod("expm", "advector", function(x) math_expm(x))
##' @describeIn ADmatrix AD matrix exponential
setMethod("expm", "adsparse", function(x) math_expm(x))

## Methods sparseMatrix -> adsparse

setMethod("Ops",
          signature("sparseMatrix", "advector"),
          function(e1, e2) callGeneric( as(e1, "adsparse") , e2) )

setMethod("Ops",
          signature("advector", "sparseMatrix"),
          function(e1, e2) callGeneric( e1, as(e2, "adsparse") ) )

setMethod("Ops",
          signature("sparseMatrix", "adsparse"),
          function(e1, e2) callGeneric( as(e1, "adsparse") , e2) )

setMethod("Ops",
          signature("adsparse", "sparseMatrix"),
          function(e1, e2) callGeneric( e1, as(e2, "adsparse") ) )

## Methods adsparse
##' @describeIn ADmatrix AD sparse matrix dimension
setMethod("dim", "adsparse", function(x) x@Dim)

setMethod("Ops",
          signature("ad", "adsparse"),
          function(e1, e2) SparseArith2(advector(e1), e2, .Generic) )
setMethod("Ops",
          signature("adsparse", "ad"),
          function(e1, e2) SparseArith2(e1, advector(e2), .Generic) )
setMethod("Ops",
          signature("adsparse", "adsparse"),
          function(e1, e2) {
              if (!identical(e1@Dim, e2@Dim))
                  stop("non-conformable arguments")
              SparseArith2(e1, e2, .Generic)
          })
setMethod("Ops",
          signature("adsparse", "missing"),
          function(e1, e2) {
              e1@x[] <- callGeneric(e1@x)
              e1
          })
setMethod("kronecker",
          signature("adsparse", "anysparse", "missing", "missing"),
          function(X, Y) SparseArith2(X, as(Y, "adsparse"), "%x%") )
setMethod("kronecker",
          signature("anysparse", "adsparse", "missing", "missing"),
          function(X, Y) SparseArith2(as(X, "adsparse"), Y, "%x%") )
##' @describeIn ADmatrix AD matrix multiply
setMethod("%*%",
          signature("anysparse", "ad"),
          function(x, y) {
              x <- as(x, "adsparse")
              y <- as.matrix(advector(y))
              if ( ncol(x) != nrow(y) )
                  stop("non-conformable arguments")
              SparseArith2(x, y, .Generic)
          })
##' @describeIn ADmatrix AD matrix multiply
setMethod("%*%",
          signature("ad", "anysparse"),
          function(x, y) {
              x <- as.matrix(advector(x))
              y <- as(y, "adsparse")
              if ( ncol(x) != nrow(y) )
                  stop("non-conformable arguments")
              SparseArith2(x, y, .Generic)
          })
##' @describeIn ADmatrix AD matrix multiply
setMethod("%*%",
          signature("adsparse", "adsparse"),
          function(x, y) {
              if ( ncol(x) != nrow(y) )
                  stop("non-conformable arguments")
              SparseArith2(x, y, .Generic)
          })
##' @describeIn ADmatrix AD matrix multiply
setMethod("%*%",
          signature("ad", "ad"),
          function(x, y) {
              y <- as.matrix(y)
              ## Promotion of a vector to a 1-row matrix
              if (is.null(dim(x)) && length(x) == nrow(y))
                  x <- t(x)
              x <- as.matrix(x)
              matmul(advector(x), advector(y))
          })
##' @describeIn ADmatrix AD matrix multiply
setMethod("tcrossprod", signature("ad", "ad."),
          function(x, y) {if (is.null(y)) y <- x; x %*% t(y)} )
##' @describeIn ADmatrix AD matrix multiply
setMethod( "crossprod", signature("ad", "ad."),
          function(x, y) {if (is.null(y)) y <- x; t(x) %*% y} )
##' @describeIn ADmatrix AD matrix cov2cor
##' @param V Covariance matrix
setMethod( "cov2cor", signature("advector"),
          function(V) {
              oldval <- TapeConfig()
              on.exit(TapeConfig(oldval))
              TapeConfig(comparison="allow")
              stats::cov2cor(V)
          })
##' @describeIn ADmatrix AD matrix inversion and solve
##' @param a matrix
##' @param b matrix, vector or missing
setMethod("solve",
          signature("ad", "ad."),
          function(a, b) {
              a <- as.matrix(a)
              ans <- matinv(advector(a))
              if (!missing(b)) {
                  b <- as.matrix(b)
                  ans <- ans %*% b
              }
              ans
          })
##' @describeIn ADmatrix AD matrix inversion and solve
setMethod("solve", signature("num", "num."),
          function(a, b) {
              base::solve(a, b)
          })
##' @describeIn ADmatrix Sparse AD matrix solve
##' @param a matrix
##' @param b matrix, vector or missing
setMethod("solve",
          signature("anysparse", "ad."),
          function(a, b) {
              a <- as(a, "adsparse")
              missing.b <- missing(b)
              if (missing.b)
                  b <- diag(nrow(a))
              ans <- SparseSolve(a, advector(as.matrix(b)))
              dim(ans) <- dim(b)
              if (missing.b)
                  ans <- as(ans, "sparseMatrix")
              ans
          })
##' @describeIn ADmatrix AD matrix (or array) colsums
##' @param na.rm Logical; Remove NAs while taping.
##' @param dims Same as \link[base]{colSums} and \link[base]{rowSums}.
setMethod("colSums", signature(x="advector"),
          function(x, na.rm, dims) {
              if (dims != 1L) stop("AD version requires dims=1")
              apply(x, seq_len(length(dim(x)))[-1L], sum, na.rm=na.rm)
          } )
##' @describeIn ADmatrix AD matrix (or array) rowsums
setMethod("rowSums", signature("advector"),
          function(x, na.rm, dims) {
              if (dims != 1L) stop("AD version requires dims=1")
              apply(x, 1L, sum, na.rm=na.rm)
          } )
##' @describeIn ADmatrix AD sparse matrix colsums
setMethod("colSums", signature(x="adsparse"),
          function(x, na.rm, dims) {
              if (dims != 1L) stop("AD version requires dims=1")
              if (na.rm) x@x[is.na(x@x)] <- 0
              drop( t(rep(1, nrow(x))) %*% x )
          } )
##' @describeIn ADmatrix AD sparse matrix rowsums
setMethod("rowSums", signature("adsparse"),
          function(x, na.rm, dims) {
              if (dims != 1L) stop("AD version requires dims=1")
              if (na.rm) x@x[is.na(x@x)] <- 0
              drop( x %*% rep(1, ncol(x)) )
          } )
##' @describeIn ADmatrix AD matrix column bind
##' @param ... As \link[base]{cbind}
cbind.advector <- function (...) {
    args <- lapply(list(...), advector)
    ans <- do.call("cbind", lapply(args, unclass))
    class(ans) <- "advector"
    asS4(ans)
}
##' @describeIn ADmatrix AD matrix row bind
rbind.advector <- function (...) {
    args <- lapply(list(...), advector)
    ans <- do.call("rbind", lapply(args, unclass))
    class(ans) <- "advector"
    asS4(ans)
}
##' @describeIn ADmatrix AD sparse matrix 'Math group' works for functions that preserve sparsity.
setMethod("Math", c(x = "adsparse"),
          function(x) {
              g <- get(.Generic, mode = "function")
              if(startsWith(.Generic, "cum") || !identical(g(0), 0))
                  stop(paste0("Unsupported operation: ", .Generic, "(adsparse)"))
              x@x <- g(x@x)
              x
          })

## Show general idea which is automated in 'distributions.R'
## First we generate the version we want for AD types (dot signifies 'default argument')
##' @describeIn Distributions AD implementation of \link[stats]{dnorm}
setMethod("dnorm", signature("ad", "ad.", "ad.", "logical."),
          function(x, mean, sd, log) {
              r <- (x - mean) / sd
              ans <- - .5 * r * r - log(sqrt(2*pi)) - log(sd)
              if (log) ans else exp(ans)
          })
## This matches 'too much', so we fix by adding a specialization:
##' @describeIn Distributions Default method
setMethod("dnorm", signature("num", "num.", "num.", "logical."),
          function(x, mean, sd, log) {
              stats::dnorm(x, mean, sd, log)
          })
## For S4 generics we add the OSA version like this:
##' @describeIn Distributions OSA implementation
setMethod("dnorm", "osa", function(x, mean, sd, log) {
    dGenericOSA(.Generic, x=x, mean=mean, sd=sd, log=log)
})
## For S4 generics we add the simref version like this:
##' @describeIn Distributions Simulation implementation. Modifies \code{x} and returns zero.
setMethod("dnorm", "simref", function(x, mean, sd, log) {
    ## works when x, mean or sd are simref
    if (inherits(mean, "simref")) {
        x <- x - mean
        mean <- 0
    }
    if (inherits(sd, "simref")) {
        x <- x / sd
        sd <- 1
    }
    dGenericSim(.Generic, x=x, mean=mean, sd=sd, log=log)
})

##' @describeIn Distributions AD implementation of \link[stats]{dlnorm}.
##' @param meanlog Parameter; Mean on log scale.
##' @param sdlog Parameter; SD on log scale.
setMethod("dlnorm", "ANY", function (x, meanlog, sdlog, log) {
    y <- log(x)
    ans <- dnorm(y, meanlog, sdlog, log=TRUE) - y
    ans <- ans[] ## if 'simref' do complete simulation
    if (log) ans else exp(ans)
})
##' @describeIn Distributions OSA implementation.
setMethod("dlnorm", "osa", function (x, meanlog, sdlog, log) {
    dGenericOSA(.Generic, x=x, meanlog=meanlog, sdlog=sdlog, log=log)
})
##' @describeIn Distributions Default method.
setMethod("dlnorm", signature("num", "num.", "num.", "logical."),
          function(x, meanlog, sdlog, log) {
              stats::dlnorm(x, meanlog, sdlog, log)
          })

##' @describeIn Distributions Minimal AD implementation of \link[stats]{plogis}
setMethod("plogis", c("advector", "missing", "missing", "missing", "missing"),
          function(q) 1 / (1 + exp(-q) ) )
##' @describeIn Distributions Minimal AD implementation of \link[stats]{qlogis}
setMethod("qlogis", c("advector", "missing", "missing", "missing", "missing"),
          function(p) log( p / ( 1 - p ) ) )

## 'diag' needs patching.
## - base::diag works fine for AD matrix input (diagonal extraction and replacement)
## - However, matrix construction has issues

##' @describeIn ADconstruct Equivalent of \link[base]{diag}
##' @param x See \link[base]{diag}.
##' @return Object of class \code{"advector"} with a dimension attribute.
setMethod("diag", signature(x="advector", nrow="ANY", ncol="ANY"),
          function(x, nrow, ncol) {
              ## Diagonal extraction: base::diag works fine
              if (length(dim(x)) >= 2)
                  return(callNextMethod())
              ## Matrix creation
              ans <- advector(base::diag(seq_along(x), nrow=nrow, ncol=ncol))
              diag(ans) <- x
              ans
          })

##' @describeIn ADconstruct Equivalent of \link[base]{matrix}
##' @param data,nrow,ncol,byrow,dimnames See \link[base]{matrix}.
setMethod("matrix", signature(data="advector"),
          function(data, nrow, ncol, byrow, dimnames) {
              ans <- callNextMethod()
              asS4(structure(ans, class="advector"))
          })
##' @describeIn ADconstruct Equivalent of \link[base]{matrix}
setMethod("matrix", signature(data="num."),
          function(data, nrow, ncol, byrow, dimnames) {
              ans <- callNextMethod()
              if (ad_context())
                  ans <- advector(ans)
              ans
          })
##' @describeIn ADapply As \link[base]{apply}
##' @param X,MARGIN,FUN,... See \link[base]{apply}
##' @return Object of class \code{"advector"} with a dimension attribute.
setMethod("apply", signature(X="advector"),
          function (X, MARGIN, FUN, ...)  {
              ans <- callNextMethod()
              if (is.complex(ans))
                  class(ans) <- "advector"
              ans
          })
##' @describeIn ADapply As \link[base]{sapply}
##' @param simplify,USE.NAMES See \link[base]{sapply}
setMethod("sapply", signature(X="ANY"),
          function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) {
              ans <- base::sapply(X, FUN, ..., simplify = FALSE, USE.NAMES = TRUE)
              ## Adapted from 'base::sapply':
              if (!isFALSE(simplify)) {
                  cl <- if (length(ans)) class(ans[[1L]]) else NULL
                  ans <- simplify2array(ans, higher = (simplify == "array"))
                  if (identical(cl, "advector")) ## FIXME: Test all elements
                      class(ans) <- cl
              }
              ans
          })

## Internal for now
mapply <- function(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) {
  if (!ad_context() || !SIMPLIFY) {
    base::mapply(FUN = FUN, ..., MoreArgs = MoreArgs, SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES)
  } else {
    args <- list(...)
    args1 <- lapply(args, function(x) x[[1]])
    args1 <- lapply(args1, function(x) if (inherits(x, "advector")) getValues(x) else x)
    F <- MakeTape(function(args) do.call("FUN", c(args, MoreArgs)) , args1)
    ptr <- .pointer(environment(F)$mod)
    list_reshape <- function(li) {
      if (!is.list(li)) return(list(li))
      x <- do.call("cbind", li)
      split(x, row(x))
    }
    args <- lapply(args, list_reshape)
    args <- unlist(args, FALSE, FALSE)
    ad_mapply(ptr, lapply(args, advector))
  }
}
##' @describeIn ADapply As \link[base]{Vectorize}
##' @param vectorize.args,SIMPLIFY See \link[base]{Vectorize}. `USE.NAMES` is currently ignored by AD version.
setMethod("Vectorize", signature(FUN="ANY"),
          function (FUN, vectorize.args, SIMPLIFY, USE.NAMES) {
            if (missing(vectorize.args)) {
              ## Copied from base::Vectorize
              arg.names <- as.list(formals(FUN))
              arg.names[["..."]] <- NULL
              vectorize.args <- names(arg.names)
            }
            VFUN <- base::Vectorize(FUN, vectorize.args, SIMPLIFY, USE.NAMES)
            ## Overload mapply
            env <- environment(VFUN)
            env$mapply <- mapply
            VFUN
          })
## Fix: no visible binding for global variable ‘arg.names’
utils::globalVariables("arg.names")

##' @describeIn ADvector Equivalent of \link[base]{ifelse}
##' @param test \code{logical} vector
##' @param yes \code{advector}
##' @param no \code{advector}
setMethod("ifelse", signature(test="num", yes="ad", no="ad"),
          function(test, yes, no) {
              yes <- advector(yes)
              no <- advector(no)
              ans <- callNextMethod()
              class(ans) <- "advector"
              ans
          })
##' @describeIn ADvector Default method
setMethod("ifelse", signature(test="num", yes="num", no="num"),
          function(test, yes, no) {
              base::ifelse(test, yes, no)
          })

################################################################################

dGenericEval <- function(.Generic, ..., log) {
    dfun <- match.fun(paste("distr", .Generic, sep="_"))
    args <- list(...)
    anyAD <- any(unlist(lapply(args, inherits, "advector")))
    args <- lapply(args, advector)
    if (!missing(log))
        args$give_log <- as.logical(log)
    ans <- do.call(dfun, args)
    if (anyAD)
        ans
    else
        getValues(ans)
}

##' @describeIn Distributions Conway-Maxwell-Poisson. Calculate density.
dcompois <- function(x, mode, nu, log = FALSE) {
    if (inherits(x,"osa"))    return (dGenericOSA( "dcompois" , x=x, mode=mode, nu=nu, log=log ))
    if (inherits(x,"simref")) return (dGenericSim( "dcompois" , x=x, mode=mode, nu=nu, log=log ))
    loglambda <- nu * log(mode)
    ans <- x * loglambda - nu * lfactorial(x)
    ans <- ans - compois_calc_logZ(loglambda, nu)
    if (log) ans else exp(ans)
}
## internal (simref)
rcompois <- function(n, mode, nu) {
    loglambda <- nu * log(mode)
    loglambda <- rep(loglambda, length.out=n)
    mapply(distr_rcompois, loglambda, nu) ## mapply re-cycles
}

##' @describeIn Distributions Conway-Maxwell-Poisson. Calculate density parameterized via the mean.
dcompois2 <- function(x, mean, nu, log = FALSE) {
    if (inherits(x,"osa"))    return (dGenericOSA( "dcompois2" , x=x, mean=mean, nu=nu, log=log ))
    if (inherits(x,"simref")) return (dGenericSim( "dcompois2" , x=x, mean=mean, nu=nu, log=log ))
    logmean <- log(mean)
    loglambda <- compois_calc_loglambda(logmean, nu)
    ans <- x * loglambda - nu * lfactorial(x)
    ans <- ans - compois_calc_logZ(loglambda, nu)
    if (log) ans else exp(ans)
}
## internal (simref)
rcompois2 <- function(n, mean, nu) {
    logmean <- log(mean)
    loglambda <- getValues(compois_calc_loglambda(advector(logmean), advector(nu)))
    loglambda <- rep(loglambda, length.out=n)
    mapply(distr_rcompois, loglambda, nu) ## mapply re-cycles
}

################################################################################

##' @describeIn Distributions AD implementation of \link[stats]{pbinom}
setMethod("pbinom",
          signature(q = "ad", size = "ad", prob = "ad",
                    lower.tail = "missing", log.p = "missing"),
          function( q, size, prob ) {
              1 - pbeta(q = prob, shape1 = q + 1, shape2 = size - q)
          })
##' @describeIn Distributions Default method
setMethod("pbinom",
          signature(q = "num", size = "num", prob = "num",
                    lower.tail = "missing", log.p = "missing"),
          function( q, size, prob ) {
              stats:: pbinom ( q=q, size=size, prob=prob )
          })

################################################################################

## 'dmultinom' is already in R so we use S4 method to enhance it.
## ?dmultinom ---> 'dmultinom is currently _not vectorized_ at all'
## First we generate the version we want for AD types (dot signifies 'default argument')
##' @describeIn Distributions AD implementation of \link[stats]{dmultinom}
setMethod("dmultinom", signature("ad", "ad.", "ad", "logical."),
          function(x, size, prob, log) {
              ## Copy/paste from stats::dmultinom and remove if/else branching
              K <- length(prob)
              if (length(x) != K)
                  stop("x[] and prob[] must be equal length vectors.")
              s <- sum(prob)
              prob <- prob / s
              if (is.null(size))
                  size <- sum(x)
              r <- lgamma(size + 1) + sum(x * log(prob) - lgamma(x + 1))
              if (log)
                  r
              else exp(r)
          })
## This matches 'too much', so we fix by adding a specialization:
##' @describeIn Distributions Default method
setMethod("dmultinom", signature("num", "num.", "num", "logical."),
          function(x, size, prob, log) {
              stats::dmultinom(x, size, prob, log)
          })
## For S4 generics we add the OSA version like this:
##' @describeIn Distributions OSA implementation
setMethod("dmultinom", "osa", function(x, size, prob, log) {
    prob <- prob / sum(prob)
    if (is.null(size)) {
        size <- sum(x@x)
    }
    ## Factorize in succesive binomials
    perm <- order(attr(x@keep, "ord")) ## FIXME: Make extractor in osa.R ?
    x <- x[perm]
    prob <- prob[perm]
    ## Binomial parameters
    "c" <- ADoverload("c")
    cumsum0 <- function(x) c(0, cumsum(x[-length(x)]))
    size <- size - cumsum0(x@x)
    size <- getValues(advector(size)) ## Not variable
    prob <- prob / (1 - cumsum0(prob))
    sum(dbinom(x, size, prob, log=TRUE))
})
## For S4 generics we add the simref version like this:
##' @describeIn Distributions Simulation implementation. Modifies \code{x} and returns zero.
setMethod("dmultinom", "simref", function(x, size, prob, log) {
    if (is.null(size)) {
        if (is.null(x$getOrig))
            stop("Failed to determine 'size' parameter to use with simulation; please specify")
        obs <- x$getOrig(seq_len(length(x)))
        size <- sum(obs)
    }
    nrep <- 1 ## dmultinom is not vectorized
    x[] <- stats::rmultinom(nrep, size=size, prob=prob)
    rep(0, nrep)
})
## To prevent unintendend usage, we change the default method.
InvalidMethod <- function(which=-2) {
    fr <- sys.frame(which)
    cl <- match.call(sys.function(which), sys.call(which), FALSE)
    cls <- sapply(names(cl[-1]), function(nm)class(get(nm, envir=fr)))
    cl[-1] <- cls
    c("Unexpected combination of classes used in AD context:\n", deparse(cl))
}
##' @describeIn Distributions Default implementation that checks for invalid usage.
setMethod("dmultinom", signature("ANY", "ANY", "ANY", "ANY"),
          function (x, size, prob, log) {
              if (ad_context()) {
                  stop(InvalidMethod())
              }
              stats::dmultinom(x=x, size=size, prob=prob, log=log)
          })

################################################################################

## dcauchy: Follow pattern of S4 dnorm
##' @describeIn Distributions AD implementation of \link[stats]{dcauchy}
setMethod("dcauchy",
          signature("ad", "ad.", "ad.", "logical."),
          function(x, location, scale, log) {
              r <- (x - location) / scale
              ans <- -log(pi) - log(scale) - log1p(r * r)
              if (log) ans else exp(ans)
          })
##' @describeIn Distributions Default method
setMethod("dcauchy",
          signature("num", "num.", "num.", "logical."),
          function(x, location, scale, log) {
              stats::dcauchy(x, location, scale, log)
          })
##' @describeIn Distributions OSA implementation
setMethod("dcauchy", "osa", function(x, location, scale, log) {
    dGenericOSA("dcauchy", x=x, location=location, scale=scale, log=log)
})
##' @describeIn Distributions Simulation implementation. Modifies \code{x} and returns zero.
setMethod("dcauchy", "simref", function(x, location, scale, log) {
    ## works when x, location or scale are simref
    if (inherits(location, "simref")) {
        x <- x - location
        location <- 0
    }
    if (inherits(scale, "simref")) {
        x <- x / scale
        scale <- 1
    }
    dGenericSim("dcauchy", x=x, location=location, scale=scale, log=log)
})

################################################################################

## dgamma patch: Make it work with 'rate' argument
##' @describeIn Distributions AD implementation of \link[stats]{dgamma}
setMethod("dgamma",
          signature(x = "ad", shape = "ad", rate = "ad", scale = "missing", log = "logical."),
          function( x, shape, rate, log ) {
            dgamma(x=x, shape=shape, scale=1/rate, log=log)
          })

################################################################################

##' @describeIn Distributions AD implementation of \link[stats]{pnbinom}
setMethod("pnbinom",
          signature(q = "ad", size = "ad", prob = "ad", mu="missing", lower.tail="missing", log.p="missing"),
          function(q, size, prob) {
            pbeta(prob, size, q+1)
          })

################################################################################

##' @describeIn Distributions General implementation of \link[stats]{dchisq} that works for all RTMB evaluation modes (\link{advector}, \link{Simulation}, \link{OSA-residuals}).
setMethod("dchisq",
          signature(x = "ANY", df = "ANY", ncp = "missing", log = "ANY"),
          function(x, df, log) {
              dgamma(x=x, shape=df/2, scale=2, log=log)
          })
##' @describeIn Distributions Standard numeric evaluation falls back on the stats version.
setMethod("dchisq",
          signature(x = "num", df = "num", ncp = "num.", log = "ANY"),
          function(x, df, ncp, log) {
              stats::dchisq(x=x, df=df, ncp=ncp, log=log)
          })

################################################################################

##' @describeIn Distributions General implementation of \link[stats]{pchisq} that works for all RTMB evaluation modes (\link{advector}, \link{Simulation}, \link{OSA-residuals}).
setMethod("pchisq",
          signature(q = "ANY", df = "ANY", ncp = "missing", lower.tail = "missing", log.p = "missing"),
          function(q, df) {
              pgamma(q=q, shape=df/2, scale=2)
          })
##' @describeIn Distributions Standard numeric evaluation falls back on the stats version.
setMethod("pchisq",
          signature(q = "num", df = "num", ncp = "num.", lower.tail = "missing", log.p = "missing"),
          function(q, df, ncp) {
              stats::pchisq(q=q, df=df, ncp=ncp)
          })

################################################################################

##' @describeIn Distributions General implementation of \link[stats]{qchisq} that works for all RTMB evaluation modes (\link{advector}, \link{Simulation}, \link{OSA-residuals}).
setMethod("qchisq",
          signature(p = "ANY", df = "ANY", ncp = "missing", lower.tail = "missing", log.p = "missing"),
          function(p, df) {
              qgamma(p=p, shape=df/2, scale=2)
          })
##' @describeIn Distributions Standard numeric evaluation falls back on the stats version.
setMethod("qchisq",
          signature(p = "num", df = "num", ncp = "num.", lower.tail = "missing", log.p = "missing"),
          function(p, df, ncp) {
              stats::qchisq(p=p, df=df, ncp=ncp)
          })

################################################################################

##' @describeIn Distributions AD implementation of \link[stats]{pnorm}
setMethod("pnorm",
          signature(q = "ad", mean = "ad.", sd = "ad.", lower.tail = "ANY", log.p = "ANY"),
          function(q, mean, sd, lower.tail, log.p) {
            q <- advector ( q )
            mean <- advector ( mean )
            sd <- advector ( sd )
            if (!log.p) {
              ans <- distr_pnorm (q, mean, sd)
              if (!lower.tail) ans <- 1 - ans
            } else {
              q <- (q - mean) / sd
              ans <- distr_log_pnorm (q, lower.tail)
            }
            ans
          })
##' @describeIn Distributions Default method
setMethod("pnorm",
          signature(q = "num", mean = "num.", sd = "num.", lower.tail = "ANY", log.p = "ANY"),
          function(q, mean, sd, lower.tail, log.p) {
            stats::pnorm( q=q, mean=mean, sd=sd, lower.tail, log.p )
          })

################################################################################
## Discrete AD methods
################################################################################

##' @describeIn ADvector Taped sorting of an AD vector
##' @examples MakeTape(sort, numeric(3))
setMethod("sort", "advector", function(x) sort_ad(x))
##' @describeIn ADvector Taped ordering of an AD vector
##' @examples MakeTape(order, numeric(3))
##' @param na.last missing
##' @param decreasing missing
##' @param method missing
setMethod("order",
          c(na.last="missing", decreasing="missing", method="missing"),
          function(...) {
            z <- list(...)
            ad.case <- any(unlist(lapply(z, inherits, "advector")))
            if (ad.case) {
              z <- lapply(z, advector)
              o <- order_ad(z[[length(z)]]) ## zero-based
              while(length(z <- z[-length(z)])) {
                x <- z[[length(z)]]
                o <- subset_ad(o, order_ad(subset_ad(x, o))) ## zero-based
              }
              o + 1
            } else {
              base::order(...)
            }
          })
##' @describeIn ADvector Taped subsetting of an AD vector
##' @examples MakeTape(function(x) AD(rivers)[x], 1:3)
##' @param i Variable indices for taped subset
setMethod("[", c("advector", "advector"), function(x, i) subset_ad(x, i-1))
##' @describeIn ADvector Taped interval finding of an AD vector
##' MakeTape(function(x) findInterval(x, AD(0:10)), 1:3)
##' @param vec Sorted vector defining the intervals to lookup
##' @param rightmost.closed,all.inside,left.open,checkSorted,checkNA See \link[base]{findInterval}.
setMethod("findInterval",
          c("advector", "advector"),
          function(x, vec, rightmost.closed, all.inside, left.open, checkSorted, checkNA) {
            find_interval_ad(x, vec, rightmost.closed, all.inside, left.open, checkSorted, checkNA)
          })
find_interval_ad <- function(x, vec, ...) {
  ix <- seq.int(from = 1L, length.out=length(x))
  iv <- seq.int(from = length(x) + 1L, length.out=length(vec))
  f <- function(xvec) {
    x <- xvec[ix]
    vec <- xvec[iv]
    base::findInterval(x, vec, ...)
  }
  DataEval(f, c(x, vec))
}
