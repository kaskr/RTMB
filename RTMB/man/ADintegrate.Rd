% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/integrate.R
\name{ADintegrate}
\alias{ADintegrate}
\alias{integrate,ANY-method}
\title{AD adaptive numerical integration.}
\usage{
\S4method{integrate}{ANY}(
  f,
  lower,
  upper,
  ...,
  subdivisions = 100L,
  rel.tol = .Machine$double.eps^0.25,
  abs.tol = rel.tol,
  stop.on.error = TRUE,
  keep.xy = FALSE,
  aux = NULL
)
}
\arguments{
\item{f}{Vectorized integrand.}

\item{lower}{Lower integration limit. May be infinite.}

\item{upper}{Upper integration limit. May be infinite.}

\item{...}{Passed to \code{f}.}

\item{subdivisions}{Max number of subdivisions.}

\item{rel.tol}{Relative tolerance.}

\item{abs.tol}{Absolute tolerance.}

\item{stop.on.error}{Stop on error?}

\item{keep.xy}{Not used.}

\item{aux}{Not used.}
}
\value{
List with components \code{"value"}, \code{"abs.error"} and \code{"subdivisions"}.
}
\description{
Univariate adaptive integration extending R's native \link[stats]{integrate} function to work in both \emph{standard} and \emph{AD} evaluation modes.
}
\details{
Standard evaluation mode simply calls \code{stats::integrate} while
AD evaluation mode re-directs to a specialized RTMB implementation.
The latter imitates the R (QUADPACK) implementation by using:
\itemize{
\item Adaptive Gauss-Kronrod (K21/G10) quadrature with fast retaping.
\item Wynn convergence acceleration to handle boundary singularites.
}

Accuracy requirements are specified via relative (\code{rel.tol}) and absolute (\code{abs.tol}) tolerances.
The AD implementation tries to follow the same stopping criterion as that used by QUADPACK, which is to stop if \emph{either} (not both!) of these tolerances are satisfied:

\verb{|error| < max ( |result| * rel.tol , abs.tol )}.

It follows that a tolerance can be disabled by setting it to zero. This is especially useful when integrating probability densities, where the relative tolerance is the relevant measure, i.e. pass \code{abs.tol=0} in this case.
}
\examples{
## Example with many sub-divisions
f <- function(x) sin(exp(x))
F <- MakeTape(function(x) integrate(f, 0, x)$value, 0)
F(7)
integrate(f, 0, 7)
## Example with singularity
f <- function(x) dbeta(x, shape1=.1, shape2=.1)
F <- MakeTape(function(x) integrate(f, 0, x)$value, 0)
F(.1)
integrate(f, 0, .1)
}
